# 제미니의 추가의견 (Gemini's Additional Feedback)

## 총평 (Overall Assessment)

프로젝트 계획 문서들은 매우 체계적이고 상세하며, 명확한 비전과 구체적인 실행 계획을 담고 있습니다. 특히 '스키마 우선 접근 방식', '단계별 구현 계획', '성능 목표 사전 정의' 등은 성공적인 프로젝트를 위한 훌륭한 초석입니다.

아래 내용은 현재의 훌륭한 설계를 더욱 견고하고 확장 가능하게 만들기 위한 비판적인 시각에서의 제안과 아이디어입니다.

---

## 구체적인 제안 및 아이디어 (Specific Suggestions & Ideas)

### 1. 이벤트 스키마 (`event-schema.md`)

- **Payload 구조 명확화:** 현재 `payload`가 범용 `object` 타입이라 유연하지만, 데이터 불일치를 유발할 수 있습니다. 핵심 이벤트 타입에 대해서는 `payload`의 스키마를 명시적으로 정의하는 것을 권장합니다.
  - 예시: `tool_failed` 이벤트의 `payload`는 `tool_name: string`, `exit_code: number | null`, `error_message: string`을 필수로 포함하도록 zod 같은 도구로 스키마를 정의할 수 있습니다. 이는 데이터를 소비하는 클라이언트의 안정성을 크게 향상시킵니다.

- **이벤트 타입 추가 제안:**
  - `agent_acknowledged`: `manager_assign` 이후, 워커가 미팅 장소로 이동하기 전에 해당 지시를 '인지했음'을 알리는 이벤트입니다. 이는 팀장의 관점에서 "지시가 전달되었는가"와 "워커가 인지하고 움직이기 시작했는가"를 구분할 수 있게 해줍니다.
  - `meeting_ended` 이벤트의 공식화: `state-machine.md`에서는 `meeting_ended` 이벤트를 가정하고 있지만, `event-schema.md`의 이벤트 카탈로그에는 빠져있습니다. 타임아웃 외에, 명시적으로 대화가 끝났음을 알리는 이벤트를 추가하고 공식화해야 합니다.

### 2. 상태 머신 (`state-machine.md`)

- **동시 작업 처리 정책:** 현재 상태 머신은 에이전트가 한 번에 하나의 작업만 처리하는 것으로 보입니다. 만약 `working` 상태의 에이전트에게 새로운 `manager_assign` 이벤트가 발생했을 때의 정책을 명확히 할 필요가 있습니다.
  - 제안: 큐(Queue) 개념 도입. 에이전트는 '현재 작업'과 '대기 중인 작업' 목록을 가질 수 있습니다. 또는, 우선순위가 높은 긴급 작업은 현재 작업을 '중단(paused)' 상태로 만들고 먼저 처리하는 정책을 정의할 수 있습니다.

- **상태 세분화:**
  - `blocked` 상태를 `failed` (복구 불가능한 실패)와 `pending_input` (사용자 입력/외부 의존성 대기)으로 세분화하면, 대시보드에서 문제의 원인을 더 명확하게 파악하고 다음 조치를 결정하는 데 도움이 됩니다.

- **미팅 장소(`meeting_point`) 계산:** 두 에이전트의 중간 지점으로 설정할 경우, 동선이 겹치거나 예상치 못한 위치에서 만날 수 있습니다. 오피스 내에 몇 개의 고정된 '미팅 스팟'을 지정하고, 가장 가까운 빈 스팟으로 이동하게 하는 방식이 시각적으로 더 안정적이고 보기 좋습니다.

### 3. 아키텍처 및 기술 스택 (`system-architecture.md`)

- **저장소 전략 구체화:** JSONL과 SQLite를 단계별 전환으로 고려하는 것보다, 각자의 장점을 살린 하이브리드 전략을 초기부터 고려하는 것이 좋습니다.
  - **JSONL (Write-Ahead-Log):** 모든 원시 이벤트를 저비용으로 빠르게 기록하는 용도로 사용합니다. (Append-only)
  - **SQLite/In-memory DB (Indexed State Store):** JSONL의 이벤트를 읽어와 '현재 상태'(`state_current` 테이블 등)를 계산하고, 이를 이곳에 저장합니다. API 조회는 이 상태 저장소를 대상으로 수행합니다. 이렇게 하면 쓰기 성능과 읽기 성능을 동시에 확보할 수 있습니다.

- **확장성 고려:** 현재의 단일 백엔드 서버는 MVP(20 에이전트) 수준에서는 충분하지만, 그 이상을 고려할 때 잠재적인 병목 지점입니다. 초기 설계에 다음을 언급해두면 좋습니다.
  - **WebSocket 브로드캐스트 분리:** 이벤트 저장/상태 계산 로직과 WebSocket 브로드캐스트 로직을 분리하고, 그 사이에 Redis Pub/Sub 같은 메시지 큐를 사용하는 구조를 v2 로드맵으로 제시할 수 있습니다.

- **API 보안 강화:** `open-questions.md`에서 언급된 인증 방식은 조기에 결정하는 것이 매우 중요합니다. 'Shared Secret'은 간단하지만 유출 시 위험이 큽니다. OAuth2 기반의 토큰(JWT 등)을 발급하고, API Gateway 등을 통해 검증하는 표준적인 방식을 채택하는 것이 장기적으로 안전합니다.

### 4. 제품 및 사용자 경험 (`product-spec.md`)

- **"시간 되돌리기(Time Travel)" 디버깅 기능:** 대시보드에서 특정 실패 이벤트가 발생했을 때, 클릭 한 번으로 해당 시점 전후의 이벤트 10~20개를 하이라이트하여 보여주는 기능은 운영 및 디버깅 생산성을 극적으로 향상시킬 수 있습니다.

- **설정(Settings) 기능의 위험성 관리:** 사용자가 UI에서 직접 상태 전이 규칙을 수정하는 기능은 매우 강력하지만, 시스템 전체를 쉽게 망가뜨릴 수 있습니다.
  - 제안: '고급 설정'으로 분리하고, 규칙 편집 전/후에 유효성 검사(Validation) 로직을 두어 '`idle` 상태로 돌아올 수 없는 규칙' 등 명백한 오류를 막는 안전장치가 필요합니다. 변경 시에는 "기본값으로 복원" 기능을 제공하는 것이 좋습니다.

- **시각적 피드백 강화:** 오피스 탭에서 에이전트가 `blocked` 또는 `failed` 상태일 때, 단순히 색상만 바꾸는 것 외에 아이콘(느낌표, X 표시)을 머리 위에 띄우거나, 미세한 '떨림' 애니메이션을 추가하면 상태의 심각성을 즉시 인지하는 데 도움이 됩니다.

### 5. 문서화 및 운영 (`README.md`, `system-architecture.md`)

- **아키텍처 다이어그램:** `system-architecture.md`에 컴포넌트와 데이터 흐름을 시각적으로 보여주는 다이어그램(예: Mermaid.js 사용)을 추가하면, 복잡한 시스템 구조를 신규 참여자가 훨씬 빠르게 이해할 수 있습니다.

---

## 추가적으로 고려해볼 리스크 (Additional Risks to Consider)

- **클라이언트 측 상태 불일치 심화:** 네트워크 지연, 메시지 유실 등으로 인해 서버가 계산한 상태와 클라이언트의 애니메이션 상태 간의 불일치가 발생할 수 있습니다. 주기적으로 서버의 '공식 상태 스냅샷'과 동기화하는 로직(예: 30초마다)을 강제하고, 상태 불일치 감지 시 UI에 경고를 표시하거나 강제 리프레시하는 기능이 필요할 수 있습니다.

- **'이벤트 폭풍(Event Storm)' 시나리오:** 특정 상황(예: 버그로 인한 무한 루프, 대규모 작업 동시 시작)에서 초당 수백 개 이상의 이벤트가 발생할 경우, 시스템이 어떻게 반응할지에 대한 방어 전략이 필요합니다.
  - 제안: Ingest 단계에서 특정 agent_id 또는 session_id로부터 오는 이벤트를 일정 시간 동안 제한(Throttling)하는 간단한 보호 장치를 고려할 수 있습니다.

- **민감 데이터 로깅:** `payload`나 `raw` 필드에 민감한 정보(개인정보, API 키 등)가 포함될 가능성이 있습니다. 초기부터 로깅 및 저장 시 특정 키(예: `password`, `token`, `secret`)를 자동으로 마스킹하는 필터 레이어를 설계에 포함하는 것이 안전합니다.

---

## 코덱스의 코멘트 (Codex Comments)

작성일: 2026-02-13

### 1) 전체 판단
- 제미니 의견은 품질이 높고, 현재 문서의 약점을 정확히 짚었습니다.
- 특히 `이벤트 계약 강화`, `상태머신 예외 정책`, `보안 조기결정`은 MVP 단계에서도 바로 반영하는 것이 맞습니다.

### 2) 즉시 채택할 항목 (MVP에 반영 권장)
- `event-schema.md`
  - `meeting_ended`를 이벤트 카탈로그에 명시 추가
  - 핵심 이벤트(`manager_assign`, `tool_failed`, `task_failed`)의 payload 필수 필드 명세 추가
- `state-machine.md`
  - `working 중 manager_assign` 충돌 정책 명시(큐잉 또는 선점 중 하나로 고정)
  - `meeting_point`를 중간점 계산이 아닌 고정 meeting spot 방식으로 변경
  - `blocked` 세분화(`failed`, `pending_input`)는 최소한 내부 상태값으로라도 반영
- `system-architecture.md`
  - JSONL(원본 append) + 상태 저장소(조회용) 하이브리드 전략을 기본안으로 승격
- `README.md` 또는 `system-architecture.md`
  - Mermaid 아키텍처 다이어그램 추가

### 3) 단계적 채택 항목 (v1.1~v2)
- `agent_acknowledged` 이벤트
  - 유용하지만 입력원에서 신뢰성 있게 생성 가능한지 먼저 검증 필요
- WebSocket 브로드캐스트 분리 + Redis Pub/Sub
  - MVP 규모(20 agents)에서는 과투자 가능성 있음. v2 확장 시점에 도입
- Time Travel 디버깅
  - 운영 가치가 높아 v1.1 우선순위로 적합

### 4) 보안 관련 판단
- Shared Secret 단독은 임시 수단으로만 사용해야 합니다.
- 최소 기준:
  - ingest 토큰 분리(환경별)
  - 민감 키 마스킹(`password`, `token`, `secret`, `api_key`)
  - settings 변경 권한 분리
- 권장 목표(v2): 사내 인증(SSO/OAuth2) 연동

### 5) 추가 보완 의견 (Codex)
- 이벤트 폭풍 대응은 문서에 명시적으로 추가해야 합니다.
  - ingest rate limit(세션/agent 단위)
  - 비핵심 이벤트 샘플링
  - 큐 길이 임계치 초과 시 백프레셔 정책
- 클라이언트 상태 불일치는 반드시 "주기적 snapshot 재동기화"를 기본 동작으로 고정해야 합니다.
  - 제안: 30초 주기 snapshot pull 또는 서버 push snapshot

### 6) 최종 결론
- 제미니 의견은 대부분 타당하며, 현재 프로젝트 문서에 반영 가치가 큽니다.
- 우선순위는 다음 순서가 적절합니다.
  1. 이벤트 스키마 엄격화
  2. 상태머신 충돌/예외 규칙 명문화
  3. 보안 최소선(토큰/마스킹/권한분리) 확정
  4. 성능/확장 대응(이벤트 폭풍, 브로드캐스트 분리) 단계적 도입
