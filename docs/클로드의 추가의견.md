# 클로드의 추가의견 (Claude's Additional Feedback)

작성자: Claude (Opus 4.6)
작성일: 2026-02-13
목적: 코덱스(Codex)가 문서만 보고 실수 없이 구현할 수 있도록 누락/모호한 지점을 보완한다.

---

## 총평

문서 체계가 매우 잘 잡혀 있고, 제미니 피드백을 반영한 일관성 정리까지 끝나 있다.
다만 **"무엇을 만들지"는 충분히 정의되어 있지만, "어떻게 만들지"에 대한 구현 수준의 명세가 부족하다.**
코덱스는 모호한 지점에서 자기 판단으로 결정하게 되는데, 그 결정이 프로젝트 의도와 어긋나면 큰 재작업이 발생한다.

아래 내용은 **코덱스가 잘못된 판단을 내릴 가능성이 높은 지점**을 중심으로 정리했다.

---

## 1. 즉시 확정이 필요한 기술 결정 (코덱스 작업 전 반드시)

`open-questions.md`에 아직 미결로 남아 있는 항목들이 있다. 코덱스에게 맡기기 전에 반드시 확정해야 한다.

### 1.1 기술 스택 확정

| 영역 | 권장 결정 | 이유 |
|------|-----------|------|
| 백엔드 | **Node.js + Fastify + ws + zod** | 문서 기존 방향과 일치. Fastify는 경량이고 스키마 검증에 강하다 |
| 프론트엔드 프레임워크 | **Vite + React (SPA)** | Next.js의 SSR/RSC는 이 프로젝트에 불필요. 대시보드는 순수 클라이언트 앱이다. Vite가 DX가 빠르고 설정이 단순하다 |
| 상태관리 | **Zustand** | 문서 기존 방향과 일치 |
| 오피스 렌더러 | **PixiJS** | Canvas 2D 직접 구현보다 스프라이트/애니메이션 관리가 압도적으로 쉽다. 20 에이전트 성능도 충분하다 |
| 저장소 | **MVP: SQLite (better-sqlite3)** | JSONL은 조회 인덱싱이 안 되므로 Time Travel과 이벤트 조회에 부적합. SQLite 단일로 시작하고, 원본 이벤트는 events 테이블에 payload_json으로 보존하면 JSONL의 역할도 겸한다 |
| 패키지 매니저 | **pnpm** | 모노레포 workspace 지원이 좋다 |
| i18n | **react-i18next** | 가장 성숙한 React i18n 라이브러리 |
| 모노레포 도구 | **pnpm workspace (turborepo 선택)** | 최소 설정으로 시작 가능 |

> **중요**: Next.js 대신 Vite를 권장하는 이유:
> - 이 대시보드는 SEO가 필요 없는 내부 도구다
> - SSR이 필요한 페이지가 하나도 없다
> - WebSocket 연결은 클라이언트에서만 관리한다
> - Vite + React Router가 훨씬 단순하다
> - 코덱스가 Next.js App Router의 서버/클라이언트 컴포넌트 경계에서 실수할 가능성을 제거한다

### 1.2 오피스 비주얼 스타일 확정

현재 `open-questions.md`에 "픽셀/SVG/일러스트" 미결이다. 코덱스에게 아트 에셋을 만들라고 할 수는 없으므로:

**권장: 단색 도형 기반 미니멀 스타일로 MVP 시작**
- 에이전트: 원형 + 이름 라벨 (색상으로 상태 구분)
- 책상: 사각형
- 탕비실: 구역 배경색 변경
- 이펙트: CSS/Canvas 기반 (종이, Zzz, 경고 아이콘)
- 추후 스프라이트 에셋이 준비되면 교체 가능한 구조로 설계

이렇게 하면 코덱스가 에셋 없이도 전체 기능을 구현할 수 있다.

---

## 2. Claude Code Hooks 실제 구조 (가장 중요한 누락)

**현재 문서의 가장 큰 갭: 실제 Claude Code Hook 이벤트의 페이로드 구조가 정의되어 있지 않다.**

코덱스가 `normalize` 함수를 작성하려면 입력 데이터의 정확한 형태를 알아야 한다.

### 2.1 Hook 설정 파일

Claude Code hooks는 `.claude/settings.json` 또는 `~/.claude/settings.json`에 설정한다:

```json
{
  "hooks": {
    "SubagentStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "curl -s -X POST http://localhost:4800/ingest/hooks -H 'Content-Type: application/json' -H 'Authorization: Bearer $DASHBOARD_TOKEN' -d \"$(cat)\""
          }
        ]
      }
    ],
    "SubagentStop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "curl -s -X POST http://localhost:4800/ingest/hooks -H 'Content-Type: application/json' -H 'Authorization: Bearer $DASHBOARD_TOKEN' -d \"$(cat)\""
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "curl -s -X POST http://localhost:4800/ingest/hooks -H 'Content-Type: application/json' -H 'Authorization: Bearer $DASHBOARD_TOKEN' -d \"$(cat)\""
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "curl -s -X POST http://localhost:4800/ingest/hooks -H 'Content-Type: application/json' -H 'Authorization: Bearer $DASHBOARD_TOKEN' -d \"$(cat)\""
          }
        ]
      }
    ],
    "Notification": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "curl -s -X POST http://localhost:4800/ingest/hooks -H 'Content-Type: application/json' -H 'Authorization: Bearer $DASHBOARD_TOKEN' -d \"$(cat)\""
          }
        ]
      }
    ],
    "Stop": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "curl -s -X POST http://localhost:4800/ingest/hooks -H 'Content-Type: application/json' -H 'Authorization: Bearer $DASHBOARD_TOKEN' -d \"$(cat)\""
          }
        ]
      }
    ]
  }
}
```

각 hook은 stdin으로 JSON을 받는다. 응답으로 JSON을 stdout에 출력할 수 있다.

### 2.2 Hook 이벤트별 실제 페이로드

#### SubagentStart
```json
{
  "session_id": "abc-def-123",
  "agent_name": "researcher",
  "agent_type": "general-purpose",
  "parent_session_id": "parent-session-456",
  "team_name": "my-project",
  "prompt": "Research the authentication patterns..."
}
```

#### SubagentStop
```json
{
  "session_id": "abc-def-123",
  "agent_name": "researcher",
  "agent_type": "general-purpose",
  "parent_session_id": "parent-session-456",
  "team_name": "my-project",
  "result": "completed"
}
```

#### PreToolUse
```json
{
  "session_id": "abc-def-123",
  "tool_name": "Bash",
  "tool_input": {
    "command": "npm test",
    "description": "Run unit tests"
  }
}
```

#### PostToolUse
```json
{
  "session_id": "abc-def-123",
  "tool_name": "Bash",
  "tool_input": {
    "command": "npm test",
    "description": "Run unit tests"
  },
  "tool_result": "... test output ...",
  "error": null
}
```

도구 실패 시:
```json
{
  "session_id": "abc-def-123",
  "tool_name": "Bash",
  "tool_input": {
    "command": "npm test"
  },
  "tool_result": null,
  "error": "Command failed with exit code 1: ..."
}
```

#### Notification
```json
{
  "session_id": "abc-def-123",
  "message": "Task completed successfully",
  "level": "info"
}
```

#### Stop
```json
{
  "session_id": "abc-def-123",
  "reason": "completed",
  "summary": "Implemented the authentication module"
}
```

### 2.3 팀 에이전트 특화 이벤트 추출 방법

**핵심: Claude Code 팀 기능의 상호작용은 도구 호출로 발생한다.**

팀장이 팀원에게 지시할 때 실제로 일어나는 것:
1. 팀장이 `Task` 도구를 호출 → `PreToolUse`로 팀원 생성 감지
2. 팀장이 `SendMessage` 도구를 호출 → `PreToolUse`로 메시지 전달 감지
3. 팀장이 `TaskUpdate` 도구를 호출 → `PreToolUse`로 작업 할당 감지

따라서 **normalize 함수는 `tool_name`과 `tool_input`을 파싱해서 시맨틱 이벤트를 추출해야 한다:**

```
PreToolUse + tool_name="Task" → agent_started (서브에이전트 생성 시도)
SubagentStart                 → agent_started (서브에이전트 실제 시작, 확정)
PreToolUse + tool_name="SendMessage" + tool_input.type="message" → manager_assign 또는 meeting_requested
PreToolUse + tool_name="TaskCreate" → task_created
PreToolUse + tool_name="TaskUpdate" + tool_input.status="completed" → task_completed
PostToolUse + tool_name 아무거나 + error 존재 → tool_failed
PostToolUse + tool_name 아무거나 + error 없음 → tool_succeeded
SubagentStop                  → agent_stopped
Stop                          → agent_stopped (메인 세션 종료)
```

### 2.4 agent_id 매핑 문제

**현재 문서의 `agent_id`(예: "manager_1", "worker_2")와 실제 Claude Code의 식별자가 다르다.**

Claude Code에서:
- 메인 세션: `session_id`로 식별 (UUID)
- 팀 에이전트: `agent_name` + `session_id`로 식별
- 팀 이름: `team_name`으로 식별

**권장 매핑 전략:**
```
dashboard agent_id = team_name + "/" + agent_name
예: "my-project/researcher", "my-project/team-lead"

메인 세션(팀장)은:
dashboard agent_id = team_name + "/leader"
```

`session_id`(UUID)는 내부 추적용으로만 사용하고, 사용자에게는 `agent_name`을 표시한다.

### 2.5 workspace_id / terminal_session_id 추출

Claude Code hook 페이로드에는 `workspace_id`가 직접 포함되지 않는다. 추출 방법:

```
workspace_id: 환경변수 $PWD에서 레포 이름 추출, 또는 hook command에서 주입
terminal_session_id: 환경변수 $CLAUDE_SESSION_ID 또는 hook 페이로드의 session_id
run_id: SubagentStart 시점의 타임스탬프 기반 생성
```

**구현 권장:** hook command에서 환경변수를 주입하는 방식:
```bash
curl -s -X POST http://localhost:4800/ingest/hooks \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer $DASHBOARD_TOKEN' \
  -d "$(jq --arg ws \"$(basename $PWD)\" --arg term \"$TERM_SESSION_ID\" '. + {workspace_id: $ws, terminal_session_id: $term}' <<< \"$(cat)\")"
```

또는 더 간단하게, 서버 측에서 클라이언트 IP + 포트 등으로 세션을 식별하고, 수동 등록 방식을 사용한다.

---

## 3. 코덱스가 실수할 가능성이 높은 모호한 지점

### 3.1 상태머신 reduce 함수의 완전한 전이표 부재

`state-machine.md`는 주요 전이만 서술형으로 기술하고 있다. 코덱스는 "문서에 없는 전이"를 만나면 자의적으로 처리할 것이다.

**권장: 완전한 전이 매트릭스를 제공하라**

```
현재상태       | 이벤트              | 다음상태        | 조건
-------------|--------------------|--------------|-----------------
idle         | task_started       | working      |
idle         | manager_assign     | handoff      | 본인이 대상일 때
idle         | timer:idle_timeout | breakroom    | idle_to_breakroom_seconds 초과
idle         | timer:idle_timeout | resting      | idle_to_resting_seconds 초과
working      | task_completed     | completed    |
working      | task_failed        | failed       | severity=error
working      | tool_failed        | failed       | payload.exit_code != 0 && 치명적
working      | tool_failed        | pending_input| 재시도 가능한 실패
working      | manager_assign     | working      | 큐에 적재 (상태 불변)
working      | manager_assign     | handoff      | priority=high일 때만
completed    | post_complete_policy| roaming     | 가중치 랜덤
completed    | post_complete_policy| breakroom   | 가중치 랜덤
completed    | post_complete_policy| resting     | 가중치 랜덤
completed    | task_started       | working      | 큐에 대기 작업 있을 때
handoff      | arrive_at_meeting  | meeting      | 두 에이전트 모두 도착
handoff      | timer:handoff_timeout| meeting    | 10초 초과 시 강제
meeting      | meeting_ended      | returning    |
meeting      | timer:meeting_timeout| returning  | 15초 초과 시 자동
returning    | arrive_at_home     | working      | 할당 작업 있음
returning    | arrive_at_home     | idle         | 할당 작업 없음
pending_input| agent_unblocked    | working      |
failed       | agent_unblocked    | working      |
failed       | timer:failed_timeout| failed      | 30초 경고 이벤트만 발행
roaming      | task_started       | working      | 좌석으로 먼저 복귀
roaming      | manager_assign     | handoff      | meeting spot으로 이동
breakroom    | task_started       | working      | 좌석으로 먼저 복귀
breakroom    | manager_assign     | handoff      | meeting spot으로 이동
breakroom    | timer:breakroom_timeout| idle     | 20분 초과
resting      | task_started       | working      |
resting      | manager_assign     | handoff      |
offline      | agent_started      | idle         |
*            | agent_stopped      | offline      | 어떤 상태에서든
*            | heartbeat          | (불변)       | last_event_ts만 갱신
```

**명시되지 않은 (상태, 이벤트) 조합은 무시(no-op)하고 `transition_ignored` 로그를 기록한다.**

### 3.2 "치명적 실패" 판정 기준 부재

`working -> failed`는 "치명적 tool_failed"일 때, `working -> pending_input`은 "재시도 가능"일 때라고 되어 있지만, **무엇이 치명적이고 무엇이 재시도 가능한지 기준이 없다.**

**권장 기준:**
```
치명적(→ failed):
- tool_failed + error에 "permission denied", "not found", "ENOENT" 등 포함
- task_failed 이벤트 (명시적 실패)
- 같은 도구가 3회 연속 실패

재시도 가능(→ pending_input):
- tool_failed + error에 "timeout", "EAGAIN", "rate limit" 등 포함
- tool_failed 1~2회 (아직 치명적 판단 전)

기본값: 판단 불가 시 pending_input으로 분류 (낙관적 처리)
```

### 3.3 roaming/breakroom/resting에서 작업 수신 시 동선

`roaming` 상태에서 `task_started`가 오면 바로 `working`으로 전환한다고 되어 있지만, **캐릭터가 현재 탕비실에 있으면 좌석까지 이동하는 시간이 필요하다.**

**권장:**
```
roaming/breakroom + task_started → returning (home_position으로 이동)
                                → arrive_at_home → working

roaming/breakroom + manager_assign → handoff (meeting_spot으로 이동)
```

즉, 비업무 상태에서 업무 이벤트를 받으면 중간에 `returning` 상태를 거쳐야 한다. 이 전이가 state-machine.md에 빠져 있다.

### 3.4 WebSocket 메시지 프로토콜 미정의

`system-architecture.md`에 메시지 타입만 나열되어 있고 실제 구조가 없다.

**권장 프로토콜 정의:**

```typescript
// 서버 → 클라이언트
type WSMessage =
  | { type: "snapshot"; data: SnapshotData }
  | { type: "event"; data: NormalizedEvent }
  | { type: "state_update"; data: AgentStateUpdate }
  | { type: "heartbeat"; ts: string }

// SnapshotData
interface SnapshotData {
  agents: AgentState[]
  tasks: TaskState[]
  sessions: SessionState[]
  settings: Settings
  server_ts: string
}

// AgentStateUpdate
interface AgentStateUpdate {
  agent_id: string
  prev_status: string
  next_status: string
  position: { x: number; y: number }
  target_position: { x: number; y: number } | null
  facing: "left" | "right" | "up" | "down"
  context: { task_id?: string; peer_agent_id?: string }
  triggered_by_event_id: string
  ts: string
}

// 클라이언트 → 서버
type WSClientMessage =
  | { type: "subscribe"; scope: ScopeFilter }
  | { type: "unsubscribe" }
  | { type: "ping" }
```

### 3.5 정직원/계약직 판별의 실제 데이터 소스

`agents-tab-spec.md`에서 `is_persisted`와 `source`로 판별한다고 했지만, **Claude Code hook 페이로드에는 이 정보가 없다.**

**실제 판별 방법:**
- Claude Code 팀에서 `.claude/agents/` 디렉토리에 정의된 에이전트 → `정직원`
- 대화 중 임시로 `Task` 도구로 생성된 에이전트 → `계약직`

**구현 권장:**
1. 서버 시작 시 `.claude/agents/` 디렉토리를 스캔하여 등록된 에이전트 목록 캐싱
2. `SubagentStart` 이벤트의 `agent_name`이 등록 목록에 있으면 `정직원`, 없으면 `계약직`
3. Settings에서 수동으로 에이전트를 `정직원`으로 승격 가능

---

## 4. 프로젝트 구조 구체화

`implementation-plan.md`의 폴더 구조가 너무 간략하다. 코덱스가 일관된 구조를 만들도록 더 상세하게 명시해야 한다.

### 4.1 권장 폴더 구조

```
agent-office-dashboard/
├── package.json                    # pnpm workspace root
├── pnpm-workspace.yaml
├── turbo.json                      # (선택) turborepo 설정
│
├── apps/
│   ├── backend/
│   │   ├── package.json
│   │   ├── tsconfig.json
│   │   ├── src/
│   │   │   ├── index.ts            # 서버 진입점 (Fastify)
│   │   │   ├── routes/
│   │   │   │   ├── ingest.ts       # POST /ingest/hooks
│   │   │   │   ├── snapshot.ts     # GET /api/snapshot
│   │   │   │   ├── events.ts       # GET /api/events, GET /api/events/:id/context
│   │   │   │   ├── sessions.ts     # GET /api/sessions
│   │   │   │   ├── agents.ts       # GET /api/agents, GET /api/agents/:id
│   │   │   │   ├── settings.ts     # GET/PUT /api/settings
│   │   │   │   ├── integration.ts  # GET /api/integration/status, POST /api/integration/hooks/install
│   │   │   │   └── state-at.ts     # GET /api/state/at (Time Travel)
│   │   │   ├── services/
│   │   │   │   ├── normalizer.ts   # hook → normalized event 변환
│   │   │   │   ├── state-machine.ts # reduce 함수 + 전이 규칙
│   │   │   │   ├── broadcaster.ts  # WebSocket 브로드캐스트
│   │   │   │   └── timer.ts        # 타임아웃/유휴 감지 스케줄러
│   │   │   ├── storage/
│   │   │   │   ├── db.ts           # SQLite 초기화
│   │   │   │   ├── events-repo.ts  # 이벤트 CRUD
│   │   │   │   ├── agents-repo.ts  # 에이전트 CRUD
│   │   │   │   ├── state-repo.ts   # 현재 상태 CRUD
│   │   │   │   └── settings-repo.ts
│   │   │   ├── ws/
│   │   │   │   └── gateway.ts      # WebSocket 서버
│   │   │   └── config.ts           # 환경변수/기본값
│   │   ├── data/
│   │   │   └── dashboard.db        # SQLite 파일 (gitignore)
│   │   └── scripts/
│   │       └── seed-mock.ts        # 테스트용 mock 데이터 시드
│   │
│   └── frontend/
│       ├── package.json
│       ├── tsconfig.json
│       ├── vite.config.ts
│       ├── index.html
│       ├── src/
│       │   ├── main.tsx            # 진입점
│       │   ├── App.tsx             # 라우팅 + 탭 레이아웃
│       │   ├── stores/
│       │   │   ├── agent-store.ts  # 에이전트 상태 (Zustand)
│       │   │   ├── event-store.ts  # 이벤트 로그
│       │   │   ├── settings-store.ts
│       │   │   └── ws-store.ts     # WebSocket 연결 관리
│       │   ├── hooks/
│       │   │   ├── useWebSocket.ts
│       │   │   └── useScope.ts     # 스코프 필터 관리
│       │   ├── pages/
│       │   │   ├── OfficePage.tsx
│       │   │   ├── DashboardPage.tsx
│       │   │   ├── AgentsPage.tsx
│       │   │   └── SettingsPage.tsx
│       │   ├── components/
│       │   │   ├── layout/
│       │   │   │   ├── TabNav.tsx
│       │   │   │   ├── ScopeBar.tsx
│       │   │   │   └── HooksBanner.tsx
│       │   │   ├── office/
│       │   │   │   ├── OfficeCanvas.tsx    # PixiJS 캔버스 래퍼
│       │   │   │   ├── AgentSprite.ts      # 에이전트 렌더 클래스
│       │   │   │   ├── DeskSprite.ts       # 책상 렌더
│       │   │   │   ├── ZoneRenderer.ts     # 구역 배경
│       │   │   │   ├── EffectManager.ts    # 이펙트(종이/절규/Zzz)
│       │   │   │   └── SpeechBubble.ts     # 말풍선
│       │   │   ├── dashboard/
│       │   │   │   ├── AgentStatusCards.tsx
│       │   │   │   ├── ActiveTaskList.tsx
│       │   │   │   ├── EventTimeline.tsx
│       │   │   │   └── TimeTravelPanel.tsx
│       │   │   ├── agents/
│       │   │   │   ├── AgentList.tsx
│       │   │   │   ├── AgentDetail.tsx
│       │   │   │   └── AgentFilters.tsx
│       │   │   └── settings/
│       │   │       ├── GeneralSettings.tsx
│       │   │       ├── OfficeLayoutSettings.tsx
│       │   │       ├── OperationsSettings.tsx
│       │   │       └── ConnectionSettings.tsx
│       │   ├── i18n/
│       │   │   ├── index.ts
│       │   │   ├── ko.json
│       │   │   └── en.json
│       │   └── lib/
│       │       ├── api.ts          # REST API 클라이언트
│       │       └── constants.ts    # 공유 상수
│       └── public/
│           └── favicon.svg
│
├── packages/
│   └── shared-schema/
│       ├── package.json
│       ├── tsconfig.json
│       └── src/
│           ├── events.ts           # zod 이벤트 스키마
│           ├── agents.ts           # zod 에이전트 스키마
│           ├── settings.ts         # zod 설정 스키마
│           ├── state.ts            # 상태 타입 정의
│           └── index.ts            # 재export
│
├── docs/
└── .gitignore
```

### 4.2 Zustand 스토어 구조 (프론트엔드)

코덱스가 스토어를 잘못 설계하면 리렌더링 지옥에 빠진다. 명시적으로 정의한다:

```typescript
// agent-store.ts
interface AgentStore {
  agents: Map<string, AgentState>       // agent_id → 현재 상태
  updateAgent: (update: AgentStateUpdate) => void
  setSnapshot: (agents: AgentState[]) => void
  getAgent: (id: string) => AgentState | undefined
  getAgentsByStatus: (status: string) => AgentState[]
}

// event-store.ts
interface EventStore {
  events: NormalizedEvent[]             // 최근 N건 (기본 500)
  maxEvents: number
  addEvent: (event: NormalizedEvent) => void
  setEvents: (events: NormalizedEvent[]) => void
  getEventsByAgent: (agentId: string) => NormalizedEvent[]
}

// ws-store.ts
interface WSStore {
  status: "connecting" | "connected" | "disconnected" | "error"
  lastHeartbeat: string | null
  connect: (url: string, scope: ScopeFilter) => void
  disconnect: () => void
}

// settings-store.ts
interface SettingsStore {
  settings: Settings | null
  loading: boolean
  fetch: () => Promise<void>
  update: (partial: Partial<Settings>) => Promise<void>
}
```

**중요: PixiJS 캔버스 안의 에이전트 위치/애니메이션은 Zustand 밖에서 관리한다.** PixiJS의 ticker로 60fps 업데이트를 하면서 매 프레임 Zustand를 읽으면 성능 문제가 생긴다. 대신:
- Zustand에서 `state_update` 이벤트를 받으면 PixiJS의 에이전트 객체에 직접 `moveTo(x, y)` 명령을 보낸다
- PixiJS 내부에서 보간(lerp)으로 부드러운 이동을 처리한다
- React와 PixiJS 사이의 브릿지는 ref로 관리한다

---

## 5. 구현 시 주의사항 (코덱스 실수 방지)

### 5.1 Hook command의 비동기 특성

Claude Code hook은 **동기적으로 실행되며 타임아웃이 있다.** hook command가 느리면 Claude Code 자체가 느려진다.

**권장:**
- `curl` 호출은 `-m 2` (2초 타임아웃) 옵션 추가
- 서버의 `/ingest/hooks`는 **즉시 응답** (200 OK) 후 비동기로 처리
- 서버가 다운되어도 hook이 Claude Code를 멈추지 않아야 한다
- `curl`에 `|| true`를 추가하여 실패해도 hook이 에러를 반환하지 않게 한다

```bash
curl -s -m 2 -X POST http://localhost:4800/ingest/hooks ... || true
```

### 5.2 이벤트 볼륨 현실적 예측

Claude Code 팀 에이전트가 활발히 작업할 때:
- 도구 호출: 에이전트당 분당 10~30회
- 20 에이전트 기준: 분당 200~600 이벤트 → 초당 3~10 이벤트
- Burst: 동시 시작 시 초당 50+ 가능

**문서의 50 events/sec burst 목표는 적절하다.** 다만 `PreToolUse`와 `PostToolUse`가 쌍으로 발생하므로 실제 이벤트는 2배로 계산해야 한다.

### 5.3 동일 이벤트의 중복 수신

네트워크 재시도로 같은 hook 이벤트가 2번 올 수 있다. 하지만 **hook 페이로드에는 고유 ID가 없다.**

**권장:**
- 서버 측에서 `sha256(JSON.stringify(payload) + ts)`로 fingerprint 생성
- 최근 60초 fingerprint를 메모리 Set에 보관하여 중복 제거
- 또는 서버가 수신 시 event_id를 생성하되, 동일 session_id + tool_name + ts(1초 이내)면 중복으로 처리

### 5.4 PixiJS와 React 통합

코덱스가 `@pixi/react` 같은 래퍼를 사용하려 할 수 있는데, **사용하지 않는 것을 권장한다.** 이유:
- 리렌더링 제어가 어렵다
- 애니메이션 로직이 React 생명주기와 맞지 않다
- 성능 저하 위험

**권장 패턴:**
```tsx
// OfficeCanvas.tsx
function OfficeCanvas() {
  const canvasRef = useRef<HTMLDivElement>(null)
  const rendererRef = useRef<OfficeRenderer | null>(null)

  useEffect(() => {
    const renderer = new OfficeRenderer(canvasRef.current!)
    rendererRef.current = renderer
    renderer.start()
    return () => renderer.destroy()
  }, [])

  // Zustand 구독 → PixiJS에 명령 전달
  useEffect(() => {
    const unsub = useAgentStore.subscribe((state) => {
      rendererRef.current?.syncAgents(state.agents)
    })
    return unsub
  }, [])

  return <div ref={canvasRef} style={{ width: '100%', height: '100%' }} />
}
```

### 5.5 SQLite 동시 접근

`better-sqlite3`는 동기 API이므로 이벤트 ingest가 많을 때 블로킹 위험이 있다.

**권장:**
- WAL 모드 활성화: `PRAGMA journal_mode=WAL`
- 쓰기는 배치 처리: 100ms 간격으로 큐에 쌓인 이벤트를 한 번에 INSERT
- 읽기와 쓰기 연결을 분리 (WAL 모드에서 가능)

---

## 6. 기능 아이디어 (MVP 이후)

### 6.1 알림 연동
- 실패/지연 발생 시 시스템 알림(Notification API) 또는 소리 재생
- 브라우저 탭 타이틀에 경고 카운트 표시: `(3) Agent Office`

### 6.2 에이전트 클릭 상호작용
- Office 탭에서 에이전트 클릭 시 말풍선에 현재 작업 요약 표시
- 더블 클릭 시 Agents 탭 상세로 이동

### 6.3 비용 추적 (v2)
- 이벤트에 토큰 사용량 필드 추가
- 에이전트별 누적 비용 표시
- Claude Code API 응답에 토큰 카운트가 포함되면 추적 가능

### 6.4 사운드 이펙트 (선택)
- 작업 완료: 짧은 성공음
- 실패: 경고음
- 전체 작업 완료: 축하 효과음
- Settings에서 on/off 제어

### 6.5 미니맵
- 에이전트가 많아지면 전체 오피스를 한 화면에 보기 어려울 수 있다
- 우하단에 미니맵으로 전체 배치 표시

### 6.6 커맨드 팔레트
- `Ctrl+K`로 빠른 검색: 에이전트 이름, 작업 ID, 이벤트 타입
- 검색 결과 클릭 시 해당 탭으로 이동

---

## 7. 문서 간 불일치/보완 필요 항목

### 7.1 implementation-plan.md Phase 순서 재검토

현재: Phase 3 (Dashboard) → Phase 3.2 (Agents) → Phase 3.5 (Time Travel) → Phase 4 (Office)

**의견:** Office 탭(Phase 4)이 이 프로젝트의 핵심 차별점이다. Dashboard는 평범한 이벤트 뷰어지만, Office는 이 프로젝트를 특별하게 만드는 요소다. Phase 순서를 재검토할 가치가 있다.

다만 **운영 도구로서의 가치를 우선**한다는 원칙(`operations-first-ux-checklist.md`)에 따르면 현재 순서가 맞다. Dashboard가 먼저 동작해야 실제로 쓸 수 있다. Office는 "재미" 요소이므로 나중이어도 괜찮다.

**결론: 현재 순서 유지. 다만 Phase 3와 Phase 4 사이에 Office 렌더러의 기초 구조만 미리 만들어 두는 것을 추천한다** (PixiJS 캔버스 + 에이전트 원형 배치만).

### 7.2 settings-spec.md의 설정과 state-machine.md의 상수 불일치

- `settings-spec.md`: `idle_to_breakroom_seconds: 180`, `idle_to_resting_seconds: 240`
- `state-machine.md`: `idle -> breakroom|resting` 트리거가 "장시간 유휴(설정 임계치 초과)"라고만 되어 있음

**보완 필요:** state-machine.md에서 정확히 어떤 설정값을 참조하는지 명시하거나, settings-spec.md의 키 이름을 state-machine.md에서 직접 참조하라.

### 7.3 meeting_spot 할당 알고리즘 미정의

`office-layout-spec.md`에 3개의 meeting spot이 정의되어 있지만, **어떤 기준으로 특정 spot을 선택하는지** 규칙이 없다.

**권장:**
1. 현재 사용 중이지 않은 spot 중 가장 가까운 것 선택
2. 모든 spot이 사용 중이면 가장 오래된 미팅의 spot을 대기열에 추가
3. 기본값: `m1` → `m2` → `m3` 순서

### 7.4 heartbeat 발행 주체 불명확

`settings-spec.md`에 `heartbeat_interval_sec: 10`이 있고, `event-schema.md`에 `heartbeat` 이벤트 타입이 있지만:
- 누가 heartbeat를 보내는가? (클라이언트? 서버? 각 에이전트?)
- Claude Code hook에서 heartbeat를 자동으로 보내지는 않는다.

**권장:**
- **서버가 자체적으로 heartbeat를 생성**하여 WebSocket 클라이언트에 push
- 에이전트별 heartbeat는 "마지막 이벤트 이후 N초 경과"로 서버가 합성(synthetic) 처리
- 클라이언트는 서버 heartbeat로 연결 상태를 판단

---

## 8. 코덱스를 위한 구현 가이드라인

### 8.1 코딩 규칙 (코덱스에게 전달)
- TypeScript strict 모드 사용
- 모든 외부 입력(hook payload, API 요청)은 zod로 검증
- 에러는 절대 삼키지 말고 최소한 console.error + 메트릭 카운트
- 매직 넘버 금지: 모든 상수는 `config.ts` 또는 `constants.ts`에 정의
- i18n: 모든 사용자 노출 문자열은 번역 키 사용 (하드코딩 금지)
- 컴포넌트: 한 파일 300줄 이하, 초과 시 분리

### 8.2 테스트 우선순위 (코덱스에게 전달)
1. **normalizer.ts 단위 테스트** (최우선): 모든 hook 타입 → normalized event 변환 검증
2. **state-machine.ts 단위 테스트**: 전이 매트릭스의 모든 행 검증
3. **ingest → broadcast 통합 테스트**: mock hook → WebSocket 메시지 수신 검증
4. **나머지는 수동 테스트로 진행** (MVP 단계)

### 8.3 mock 이벤트 생성기 요구사항

`implementation-plan.md`에 체크리스트로만 있는 mock 생성기를 구체화한다:

```
scripts/seed-mock.ts:
- CLI로 실행: npx tsx scripts/seed-mock.ts
- 시나리오 기반 이벤트 시퀀스 생성:
  1. "기본 작업": agent_started → task_created → task_started → tool_started → tool_succeeded (x5) → task_completed
  2. "지시 흐름": manager_assign → agent_acknowledged → meeting_started → meeting_ended → task_started → task_completed
  3. "실패 복구": task_started → tool_failed → (pending_input) → agent_unblocked → tool_succeeded → task_completed
  4. "연속 실패": task_started → tool_failed (x3) → task_failed
- 각 시나리오는 현실적인 시간 간격(1~5초)으로 이벤트를 /ingest/hooks에 POST
- 에이전트 수 파라미터: --agents 5 (기본 5명)
```

---

## 9. 리스크 평가 (코덱스 작업 시)

| 리스크 | 확률 | 영향 | 완화 |
|--------|------|------|------|
| 코덱스가 Next.js App Router를 사용하여 서버/클라이언트 혼란 | 높음 | 중 | Vite SPA로 확정하여 원천 차단 |
| PixiJS와 React 통합에서 메모리 누수 | 중 | 높 | ref 패턴 명시, destroy 필수 |
| hook payload 구조를 모르고 잘못된 normalize 작성 | 높음 | 높 | 이 문서에서 실제 페이로드 명시 |
| SQLite 동시 쓰기 병목 | 중 | 중 | WAL + 배치 INSERT 명시 |
| i18n 키를 나중에 추가하려다 누락 | 높음 | 낮 | 처음부터 i18n 키로 작성 강제 |
| 상태머신 전이 누락으로 에이전트가 stuck | 중 | 높 | 완전한 전이표 제공 + 기본 fallback(무시) |

---

## 10. 최종 체크리스트 (문서 반영 후 코덱스에게 넘기기 전)

- [ ] 기술 스택 확정하여 `open-questions.md` 또는 별도 문서에 기록
- [ ] 이 문서의 Section 2 (Hooks 실제 구조)를 별도 문서(`hooks-payload-spec.md`)로 분리하거나 `event-schema.md`에 통합
- [ ] 상태머신 전이 매트릭스를 `state-machine.md`에 추가
- [ ] WebSocket 메시지 프로토콜을 `system-architecture.md`에 추가
- [ ] 폴더 구조를 `implementation-plan.md`에 반영
- [ ] mock 생성기 스펙을 `implementation-plan.md`에 반영
- [ ] meeting_spot 할당 알고리즘을 `office-layout-spec.md`에 추가
- [ ] heartbeat 발행 주체를 `event-schema.md`와 `system-architecture.md`에 명시
- [ ] 비업무 상태(roaming/breakroom)에서 작업 수신 시 returning 경유를 `state-machine.md`에 추가
- [ ] "치명적 실패" 판정 기준을 `state-machine.md`에 추가
