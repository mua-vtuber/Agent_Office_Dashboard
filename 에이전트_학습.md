# Claude Code 팀 에이전트 학습 노트

## 핵심 개념

팀 에이전트는 여러 AI 에이전트를 동시에 띄워 협업시키는 시스템.
모든 에이전트는 같은 Claude 모델이지만, **컨텍스트 분리**를 통해 각자의 역할에 집중시킨다.

> 역할 분리의 본질은 회사 흉내가 아니라,
> **"컨텍스트 윈도우라는 한정된 자원을 어떻게 배분하느냐"**이다.

---

## 팀 라이프사이클

```
TeamCreate → TaskCreate → Task(팀원 스폰) → 작업 → shutdown_request → TeamDelete
```

1. `TeamCreate`로 팀 생성 (설정파일 + 태스크리스트 자동 생성)
2. `TaskCreate`로 할일 등록, `TaskUpdate`로 팀원에게 배정
3. `Task` 도구로 팀원(에이전트) 스폰 — 각각 독립 컨텍스트
4. `SendMessage`로 팀원간 소통 (팀장에게 자동 수신)
5. 완료 후 `shutdown_request` → `TeamDelete`로 해산

---

## 에이전트 타입별 도구 권한

### 빌트인 타입

| 타입 | Read | Edit/Write | Bash | Web | Task | 용도 |
|------|:----:|:----------:|:----:|:---:|:----:|------|
| general-purpose | O | O | O | O | O | 실제 구현 작업 (만능) |
| Plan | O | X | X | O | X | 설계, 조사 (읽기 전용) |
| Explore | O | X | X | O | X | 코드 분석, 리서치 (읽기 전용) |
| Bash | X | X | O | X | X | 명령어 실행 전용 |

### 커스텀 에이전트 (`.claude/agents/*.md`)

커스텀 에이전트는 **general-purpose 권한을 그대로 상속**받는다.
`.md` 파일에 "이걸 하지 마라"고 적어도 도구 자체가 차단되는 건 아님 (소프트 제한).

```
예: .claude/agents/reviewer.md에 "파일을 수정하지 마라"고 적으면
    → 대부분 안 하지만, 도구 자체는 사용 가능한 상태
    → 100% 보장이 필요하면 Plan 타입으로 스폰해야 함
```

> `code-simplifier`도 빌트인처럼 보이지만 사실 커스텀 에이전트 (general-purpose 기반).

---

## 커스텀 에이전트 정의

### 저장 위치
- 프로젝트 전용: `.claude/agents/역할이름.md`
- 전역 (모든 프로젝트): `~/.claude/agents/역할이름.md`

### 형식
마크다운 파일에 역할, 규칙, 참조 문서를 자연어로 작성.
**파일명이 곧 `subagent_type` 이름**이 된다.

### 사용법

```
Task 도구 호출 시:
  subagent_type: "rust-dev"     ← .claude/agents/rust-dev.md 로드
  subagent_type: "qa"           ← .claude/agents/qa.md 로드
  subagent_type: "general-purpose"  ← 빌트인 (커스텀 파일 없음)
```

### 좋은 에이전트 프롬프트의 구성

1. **역할 한 줄 요약** — 이 에이전트가 뭘 하는지
2. **담당 범위** — 어떤 디렉토리/파일을 다루는지
3. **참조 문서** — 반드시 읽어야 할 스펙 문서 목록
4. **코딩 규칙** — 반드시 지켜야 할 규칙 (구체적으로)
5. **작업 방식** — 어떤 순서로 일하는지

> 프롬프트에 없는 건 안 한다. "당연히 알겠지"는 통하지 않는다.

---

## 왜 역할을 나누는가 (컨텍스트 분리)

### 문제: 한 에이전트에 모든 역할

```
팀원 메시지 수신/발신 + 태스크 관리 + 기획 + 코드 리뷰 + ...
→ 컨텍스트가 잡음으로 차서 모든 작업 품질 하락
```

### 해결: 역할별 컨텍스트 보호

```
기획자 컨텍스트 = 프로젝트 구조 + 조사 결과 + 설계 비교
개발자 컨텍스트 = 승인된 설계 + 구현 코드 + 에러 해결
리뷰어 컨텍스트 = 완성 코드 + 코드 규칙 (구현 맥락 없이 객관적)
```

> 같은 모델이라도 컨텍스트에 뭐가 들어있느냐에 따라 출력 품질이 다르다.

---

## Plan Approval (계획 승인 시스템)

팀원을 `mode: "plan"` 으로 스폰하면:

```
팀원 → 계획 수립 → ExitPlanMode
                      ↓
       팀장에게 plan_approval_request 자동 전송
                      ↓
       팀장 검토 → 승인 → 팀원 구현 시작
                → 거부 → 피드백과 함께 반려
```

### 언제 쓰는가
- 설계 검토가 필요한 대규모 작업
- 여러 접근 방식 중 선택이 필요할 때
- 팀원이 잘못된 방향으로 달리는 걸 방지하고 싶을 때

### 언제 안 쓰는가
- 이미 스펙이 확정된 단순 구현
- 속도가 중요한 작업 (plan approval은 오버헤드)

---

## 실용적 팀 구성

### 소규모 (2~3명) — 단순 기능 추가, 버그 수정

```
팀장 (기획 겸임)
├── developer
└── tester
```

### 중규모 (4명+) — 복잡한 기능, 다중 모듈

```
팀장 ─── 태스크 분배, 최종 판단
├── planner ──── 설계, 조사
├── developer ── 코드 작성
├── reviewer ─── 코드 품질 검증
├── ci-fixer ─── CI 통과 책임
└── stylist ──── CSS/SVG 일관성
```

### 팀을 안 쓸 때

단순 작업에 팀을 구성하면 오버헤드가 더 크다.

- 파일 1~2개 수정하는 버그 수정
- 단일 모듈 내 리팩토링
- 명확한 지시가 있는 소규모 작업

> 에이전트 1명 스폰 = API 호출 1세트 추가.
> 쓸데없이 많이 띄우면 비용만 늘어나고 조율 오버헤드도 생긴다.

---

## 각 역할 상세

### 팀장 (team-lead)
- 태스크 분배 및 우선순위 관리
- 팀원 메시지 허브 (자동 수신)
- plan approval 검토
- idle 에이전트 깨워서 재배정 가능

### 기획자 (planner)
- **강점**: 컨텍스트 전체를 사고에 사용 가능
- 이름표가 아이디어를 만드는 게 아님
- 프롬프트로 "조사 → 비교 → 근거 제시" 절차를 강제하는 것이 핵심
- Plan 타입 권장 (코드 수정 불가 → 설계에만 집중)

### 검증자 (reviewer)
- 코드를 짠 맥락 없이 결과물만 봄 → 객관적 검증
- 체크리스트 기반 (하드코딩, 타입 안전, 패턴 일관성 등)
- 심각도 분류하여 보고

### CI 관리자 (ci-fixer)
- **체감 효과 가장 큼**
- PR의 빨간불 자동 분석 → 수정 → 초록불
- lint, 타입, 테스트, 빌드 에러 대응
- 규칙: 테스트 삭제/skip 금지, lint rule disable 금지

### 스타일리스트 (stylist)
- "디자이너"보다 "UI 구현자"에 가까움
- 가능: CSS, 레이아웃, 반응형, SVG, 디자인 시스템 일관성
- 한계: 미적 감각 창작, 렌더링 결과 판단, Figma 연동

---

## 병렬 작업 시 주의사항

### 파일 충돌

여러 에이전트가 **같은 파일을 동시에 수정하면 덮어씌워질 수 있다**.

```
rust-dev: config.rs 수정 중...
webview-dev: config.rs 수정 중... (동시에)
→ 나중에 쓴 쪽이 이전 변경을 날림
```

**방지 방법:**
- `blockedBy`로 순서 강제 — 같은 파일을 건드리는 태스크는 직렬화
- 담당 범위를 명확히 분리 — Rust 에이전트는 `src-tauri/`, WebView 에이전트는 `apps/webview/`
- 공유 파일(타입 정의, config 스키마)은 한 에이전트만 담당

### 백그라운드 실행

```
Task 도구에서 run_in_background: true 설정 시:
→ 에이전트가 백그라운드에서 실행
→ 메인 에이전트는 다른 일 계속 진행 가능
→ 결과는 output_file 경로로 확인
```

- 독립적인 작업(리서치, 테스트 실행)에 유용
- 결과를 기다려야 하는 작업에는 부적합

---

## MCP 도구 라우팅 (외부 API 연동)

MCP 서버를 등록하면 에이전트가 외부 도구를 사용 가능.

### 가능한 것
- MCP 도구를 에이전트가 호출
- 프롬프트에 라우팅 규칙 정의 → 규칙 기반 도구 선택
- 팀원별 도구 차등 배정 (커스텀 에이전트로)

### 불가능한 것
- 에이전트가 스스로 토큰 비용을 인식하고 판단
- 응답 품질 평가 후 자동 재시도
- 실시간 예산 모니터링

> **"언제 어떤 도구를 쓸지" 규칙을 명시적으로 프롬프트에 적어야 한다.**
> "알아서 해줘"는 안 되고, "이런 경우엔 이걸 써"라고 가르쳐야 한다.

---

## [중요] "다 했습니다" 사기 방지

### 문제

AI에게 기능을 만들어달라고 하면 높은 확률로 이렇게 된다:

```
AI: "다 완성했습니다!"
나: (화면 확인)
나: "...아무것도 안 바뀌었는데?"
AI: "백엔드 로직은 다 되어있습니다!"
```

백엔드/시스템 로직만 만들고 UI에 연결하지 않아서
기능이 공중에 떠 있는 상태. 코드 안에 존재하지만
사용자가 접근할 방법이 없다.

> AI는 "기능 구현"을 "시스템 로직 작성"으로 이해한다.
> 사용자의 "완료"와 개발자의 "완료"가 다르다.

### 해결: QA 에이전트에 완성 기준 심기

별도의 ux-validator를 만들 필요 없이,
**QA 에이전트에 Definition of Done을 넣으면 된다.**

```markdown
# qa.md 안에:

## 완성 기준 (Definition of Done)
1. 시스템 로직이 구현되어 동작한다
2. UI에서 해당 기능에 접근할 수 있다
3. 시스템과 UI가 연결되어 실제로 동작한다
4. 사용자가 화면에서 결과를 확인할 수 있다

"시스템 로직만 완성"은 미완성이다.
```

### 보완: 팀장 프롬프트에도 한 줄 추가

```
"모든 기능 태스크는 [시스템] + [UI] + [연결검증] 3개로 분해할 것.
 UI 태스크 없는 시스템 태스크는 만들지 말 것."
```

QA가 최종 판정하고, 팀장이 태스크 분해 시 UI를 빠뜨리지 않게 하면
이중으로 방지된다.

### 판정 예시

```
[FAIL] 상태 전이 — Rust 로직 있지만 WebView 애니메이션 전환 없음
[FAIL] 설정 변경 — config.toml 파싱은 되지만 트레이 메뉴에서 접근 불가
[PASS] 에러 표시 — Rust AppError → IPC → error-store → ErrorOverlay 화면 표시
```

> **한 줄 요약: "사용자가 마우스로 도달할 수 없으면 미완성이다."**

---

## 비용 인식

팀 에이전트는 편리하지만 공짜가 아니다.

| 구성 | 대략적 비용 배수 |
|------|:---------------:|
| 에이전트 1명 (팀 없이) | 1x |
| 팀장 + 팀원 2명 | ~3x |
| 팀장 + 팀원 4명 | ~5x |
| 팀원끼리 메시지 주고받기 | 각 메시지마다 +1 턴 |

- 에이전트 수 = API 호출 수. 병렬이면 빠르지만 비용은 그대로
- 팀원간 메시지가 많아지면 조율 비용이 실제 작업 비용을 넘을 수 있음
- **단순 작업은 팀 없이 하는 게 낫다**

---

## 팁

- idle 상태는 정상임. 메시지 보내면 자동으로 깨어남
- 태스크 의존성(`blockedBy`)으로 실행 순서 제어 가능
- 팀 설정: `~/.claude/teams/{team-name}/config.json`
- 태스크 목록: `~/.claude/tasks/{team-name}/`
- 팀원은 이름(name)으로 참조 (agentId 아님)
- 팀원의 프롬프트에 없는 건 안 한다 — "당연히 알겠지"는 안 됨
- 같은 파일을 여러 에이전트가 건드리지 않게 담당 범위를 겹치지 않게 설계
